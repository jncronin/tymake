// Set TARGET if not already set
TARGET ?= "x86_64";
YASM ?= "yasm";

/* Use debug serial port output */
DEBUG = 1;
//TYSILAFLAGS = "-fprofile";
TYSILAFLAGS = "";

ROOT = "../../..";

function x86_yasm()
{
	export rulefor "%.o" inputs { "%.asm" } depends { "test.tmk" } {
		shellcmd("$YASM $YASMFLAGS -o $_RULE_OUTPUT $_RULE_INPUT");
	}
}

function tycobj(string name)
{
	return ROOT + "/tysos/" + name;
}

if (TARGET == "x86_64")
{
	CC = "f:/cygwin64/usr/local/cross/bin/x86_64-elf-gcc.exe";
	AR = "x86_64-elf-ar";
	RANLIB = "x86_64-elf-ranlib";
	YASMFLAGS = "-felf64";
	TYSILAARCH = "x86_64s-elf64-tysos";
	LDFLAGS = "-fno-use-linker-plugin -Ttext 0x40000000 -nostdlib";
	TYSOS_CPU_OBJ = [ tycobj("x86_64/cpu.o"), tycobj("x86_64/halt.o"), tycobj("x86_64/exceptions.o"), tycobj("x86_64/switcher.o") ];
	LIBSUPCS_CPU_OBJ = [ ROOT + "/libsupcs/x86_64_arith.o", ROOT + "/libsupcs/x86_64_cpu.o", ROOT + "/libsupcs/x86_64_Invoke.o" ];
	CFLAGS = "-ffreestanding -mno-red-zone -mno-sse -mno-sse2 -mno-mmx -mno-sse3 -mno-3dnow";
	USE_UEFI = 1;
	
	x86_yasm();
}
else if (TARGET == "x86")
{
	CC = "i586-elf-gcc";
	YASMFLAGS = "-felf";
	TYSILAARCH = "i586-elf-tysos";
	USE_GRUB = 1;

	x86_yasm();
}
else if (TARGET == "arm")
{
	CC = "arm-none-elf-gcc";
	TYSILAARCH = "arm-elf-tysos";
}

// Rules
function objfromexe(string exe)
{
	return dir(exe) + "/" + basefname(exe) + ".obj";
}

TYSILAPROJ = ROOT + "/tysila2/tysila2.csproj";
TYSILA = typroject(TYSILAPROJ, "Release", "3.5", 1);
TYSOS = typroject(ROOT + "/tysos/tysos.csproj", "Release", "3.5", 1);
TYSOSOBJ = objfromexe(TYSOS);
MSCORLIB = ROOT + "/mono/corlib/mscorlib.dll";
MSCORLIBOBJ = objfromexe(MSCORLIB);
LIBSUPCS = typroject(ROOT + "/libsupcs/libsupcs.csproj", "Release", "3.5", 1);
LIBSUPCSOBJ = objfromexe(LIBSUPCS);
LIBSUPCSA = dir(LIBSUPCS) + "/" + basefname(LIBSUPCS) + ".a";
LIBSTDCS = typroject(ROOT + "/libstdcs/libstdcs.csproj", "Release", "3.5", 1);
LIBSTDCSOBJ = objfromexe(LIBSTDCS);
LIBASMOBJ = objfromexe(typroject(ROOT + "/libasm/libasm.csproj", "Release", "3.5", 1));
LIBTYSILAOBJ = objfromexe(typroject(ROOT + "/libtysila/libtysila.csproj", "Release", "3.5", 1));
MSCORLIBDIR = dir(MSCORLIB);
TINYGCOBJ = ROOT + "/tinygc/gc.o";

KERNEL = ROOT + "/tysos.bin";

/* Rules for char-conversions */
CC_DIR = ROOT + "/unicode_support/char-conversions";
CHAR_CONVERSIONS_PROG = typroject(CC_DIR + "/char-conversions.csproj");
CC_INTERMEDIATE = CC_DIR + "/category-dump";
CC_OUTPUT = CC_DIR + "/char-conversions.cs";

rulefor CC_INTERMEDIATE depends { CHAR_CONVERSIONS_PROG } {
	shellcmd("$CHAR_CONVERSIONS_PROG --dump $CC_INTERMEDIATE");
}

rulefor CC_OUTPUT inputs { CC_INTERMEDIATE } depends { CHAR_CONVERSIONS_PROG } {
	shellcmd("$CHAR_CONVERSIONS_PROG --encode $CC_INTERMEDIATE CategoryData $CC_OUTPUT");
}

rulefor ROOT + "/tysos/lib/char-conversions.cs" inputs { CC_OUTPUT } {
	cp(_RULE_INPUT, _RULE_OUTPUT);
}

/* Rules for UnicodeData */
US_DIR = ROOT + "/unicode_support";
US_PROG = typroject(US_DIR + "/unicode_support.csproj");
US_INPUT = US_DIR + "/UnicodeData.txt";
US_OUTPUT = US_DIR + "/UnicodeData.cs";

rulefor US_OUTPUT inputs { US_INPUT } depends { US_PROG } {
	shellcmd("$US_PROG -o $US_OUTPUT $US_INPUT");
}

rulefor ROOT + "/tysos/lib/UnicodeData.cs" inputs { US_OUTPUT } {
	cp(_RULE_INPUT, _RULE_OUTPUT);
}

/* Rules for mscorlib sources */
CORLIB_DIR = ROOT + "/mono/corlib";
CORLIB_SRC = CORLIB_DIR + "/corlib.dll.sources";
CORLIB_OPTS = CORLIB_DIR + "/corlib.dll.sources.options";
CORLIB_TY_SRCS = CORLIB_DIR + "/corlib.dll.ty.sources";
CORLIB_DLL = CORLIB_DIR + "/mscorlib.dll";

rulefor CORLIB_TY_SRCS inputs { CORLIB_SRC, CORLIB_OPTS } {
	f_a = fopen(CORLIB_OPTS);
	b_a = [];
	f_a.Read(b_a, 0, f_a.Length);

	f_b = fopen(CORLIB_SRC);
	b_b = [];
	f_b.Read(b_b, 0, f_b.Length);

	b_o = [];
	b_o.addrange(b_a);
	b_o.addrange(strtoarr("#assemblyname mscorlib.dll\n\n"));
	b_o.addrange(b_b);

	f_o = fopen(CORLIB_TY_SRCS);
	f_o.Write(b_o, 0, b_o.length);
	f_o.Close();
}

build(CORLIB_TY_SRCS);
typroject(CORLIB_TY_SRCS);

/* Rules for assembling CLR binaries */
rulefor "%.obj" inputs { "%.exe" } depends { TYSILA, CORLIB_DLL, "test.tmk" } {
	shellcmd("$TYSILA -o $_RULE_OUTPUT $TYSILAFLAGS --arch $TYSILAARCH -q -c -L$MSCORLIBDIR $_RULE_INPUT");
}
rulefor "%.obj" inputs { "%.dll" } depends { TYSILA, CORLIB_DLL, "test.tmk" } {
	shellcmd("$TYSILA -o $_RULE_OUTPUT $TYSILAFLAGS --arch $TYSILAARCH -q -c -L$MSCORLIBDIR $_RULE_INPUT");
}

rulefor KERNEL inputs { TYSOSOBJ, LIBSTDCSOBJ, MSCORLIBOBJ, LIBASMOBJ, LIBTYSILAOBJ, tycobj("undefined.o"),
	TYSOS_CPU_OBJ, TINYGCOBJ, LIBSUPCSA } {
	shellcmd("$CC -o $_RULE_OUTPUT $LDFLAGS -e kmain $_RULE_INPUTS");
}

rulefor "%.o" inputs { "%.c" } depends { "test.tmk" } {
	shellcmd("$CC -o $_RULE_OUTPUT $CFLAGS -c $_RULE_INPUT");
}

rulefor "%.o" inputs { "%.s" } depends { "test.tmk" } {
	shellcmd("$CC -o $_RULE_OUTPUT $CFLAGS -c $_RULE_INPUT");
}

rulefor LIBSUPCSA inputs { LIBSUPCSOBJ, LIBSUPCS_CPU_OBJ } depends { "test.tmk" } {
	shellcmd("$AR -cru $_RULE_OUTPUT $_RULE_INPUTS");
	shellcmd("$RANLIB $_RULE_OUTPUT");
}

/* Rules for EFI applications */

EFICC = "x86_64-w64-mingw32-gcc";
EFIAR = "x86_64-w64-mingw32-ar";
EFILIBCDIR = ROOT + "/tload/tloadefi/efilibc";
ZLIBDIR = ROOT + "/tload/tloadefi/zlib";
CONFUSEDIR = ROOT + "/tload/tloadefi/confuse-2.7/src";
EFICFLAGS = "-I" + EFILIBCDIR + "/inc -I" + EFILIBCDIR + "/efi/inc -I" + EFILIBCDIR + "/efi/inc/protocol -I" + EFILIBCDIR + "/efi/inc/x86_64 -I" 
	+ EFILIBCDIR + " -I" + EFILIBCDIR + "/efi -I" + ZLIBDIR + " -I" + CONFUSEDIR + " -ffreestanding -std=gnu11 -Wall -Wextra -Werror";
EFILDFLAGS = "-nostdlib -fno-use-linker-plugin -Wl,-dll -shared -Wl,--subsystem,10 -e efi_main";

rulefor "%.efi.o" inputs { "%.c" } depends { "test.tmk" } {
	shellcmd("$EFICC -o $_RULE_OUTPUT $EFICFLAGS -c $_RULE_INPUT");
}
rulefor "%.efi.o" inputs { "%.s" } depends { "test.tmk" } {
	shellcmd("$EFICC -o $_RULE_OUTPUT $EFICFLAGS -c $_RULE_INPUT");
}

EFILIBC = EFILIBCDIR + "/libefilibc.a";
rulefor EFILIBC inputs { EFILIBCDIR + "/abort.efi.o", EFILIBCDIR + "/atof.efi.o", EFILIBCDIR + "/console.efi.o", EFILIBCDIR + "/data.efi.o",
	EFILIBCDIR + "/efilibc.efi.o", EFILIBCDIR + "/file.efi.o", EFILIBCDIR + "/malloc.efi.o", EFILIBCDIR + "/misc.efi.o", EFILIBCDIR + "/printf.efi.o",
	EFILIBCDIR + "/scanf.efi.o", EFILIBCDIR + "/serial.efi.o", EFILIBCDIR + "/string.efi.o", EFILIBCDIR + "/strtod.efi.o", EFILIBCDIR + "/strtol.efi.o",
	EFILIBCDIR + "/strtoll.efi.o", EFILIBCDIR + "/strtoull.efi.o" } depends { "test.tmk" } {
	shellcmd("$EFIAR rcs $_RULE_OUTPUT $_RULE_INPUTS");
}

ZLIB = ZLIBDIR + "/libz.a";
rulefor ZLIB inputs { ZLIBDIR + "/adler32.efi.o", ZLIBDIR + "/compress.efi.o", ZLIBDIR + "/crc32.efi.o",
	ZLIBDIR + "/deflate.efi.o", ZLIBDIR + "/gzclose.efi.o", ZLIBDIR + "/gzlib.efi.o", ZLIBDIR + "/gzread.efi.o",
	ZLIBDIR + "/gzwrite.efi.o", ZLIBDIR + "/infback.efi.o", ZLIBDIR + "/inffast.efi.o", ZLIBDIR + "/inflate.efi.o",
	ZLIBDIR + "/inftrees.efi.o", ZLIBDIR + "/trees.efi.o", ZLIBDIR + "/uncompr.efi.o", ZLIBDIR + "/zutil.efi.o" } depends { "test.tmk" }
{
	shellcmd("$EFIAR rcs $_RULE_OUTPUT $_RULE_INPUTS");
}

CONFUSE = CONFUSEDIR + "/libconfuse.a";
rulefor CONFUSE inputs { CONFUSEDIR + "/confuse.efi.o", CONFUSEDIR + "/lexer.efi.o" } depends { "test.tmk" }
{
	shellcmd("$EFIAR rcs $_RULE_OUTPUT $_RULE_INPUTS");
}

EFILOADER = ROOT + "/efiloader/efiloader.bin";
rulefor EFILOADER inputs { ROOT + "/efiloader/main.efi.o", ROOT + "/efiloader/tloadkif.efi.o", ROOT + "/efiloader/load.efi.o",
	ROOT + "/efiloader/elf.efi.o", ROOT + "/efiloader/vmem.efi.o", ROOT + "/efiloader/modules.efi.o",
	ROOT + "/efiloader/kif.efi.o", ROOT + "/efiloader/cfg.efi.o", ROOT + "/efiloader/tramp.efi.o" } depends { EFILIBC, ZLIB, CONFUSE } {
	shellcmd("$EFICC -o $_RULE_OUTPUT $EFILDFLAGS -L$EFILIBCDIR -L$ZLIBDIR -L$CONFUSEDIR $_RULE_INPUTS -lz -lconfuse -lefilibc -lgcc");
}

rulefor ROOT + "/efiloader/tloadkif.c" inputs { TYSOS } depends { TYSILA, MSCORLIB }
{
	shellcmd("$TYSILA --arch $TYSILAARCH -q -L$MSCORLIBDIR --output-header $ROOT/efiloader/tloadkif.h --output-cinit $ROOT/efiloader/tloadkif.c $TYSOS");
}

/* TinyGC garbage collection library and associated support files */
SETJMP = "../../../tinygc/setjmp." + TARGET + ".o";
TINYGC_SRCS = [ ROOT + "/tinygc/dlmalloc.tgc.o", ROOT + "/tinygc/printf.tgc.o", ROOT + "/tinygc/sbrk.tgc.o",
	ROOT + "/tinygc/stdlib.tgc.o", ROOT + "/tinygc/tinygc.tgc.o", SETJMP ];
if(DEBUG) {
	TINYGC_SRCS.add(ROOT + "/tinygc/serport.tgc.o");
}

rulefor "%.tgc.o" inputs { "%.c" } depends { "test.tmk" } {
	shellcmd("$CC -o $_RULE_OUTPUT -I$ROOT/tinygc $CFLAGS -c $_RULE_INPUT");
}

rulefor TINYGCOBJ inputs { TINYGC_SRCS } depends { "test.tmk" } {
	shellcmd("$CC -Wl,-r $LDFLAGS -o $_RULE_OUTPUT $_RULE_INPUTS");
}

print("Building for $TARGET\n");

OUTDIR = ROOT + "/iso_image";
autodir(OUTDIR);
ISODIR = OUTDIR + "/iso";
autodir(ISODIR);
BOOTDIR = ISODIR + "/boot";
autodir(BOOTDIR);
GRUBDIR = BOOTDIR + "/grub";
autodir(GRUBDIR);

ISOIMAGE = OUTDIR + "/tysos.iso";
GRUBCFG = OUTDIR + "/grub.cfg";

PROCESSES = [ typroject(ROOT + "/testsuite/test_002/test_002.csproj") ];

GRUB_MKIMAGE = "grub-mkimage";
COREIMG = OUTDIR + "/core.img";
XORRISO = "xorriso";
CDBOOT = "f:/cygwin64/usr/local/lib/grub/i386-pc/cdboot.img";
GRUBPREFIX_CFG = OUTDIR + "/grub_prefix.cfg";
ELTORITO = GRUBDIR + "/eltorito.img";

if(defined(USE_GRUB))
{
	rulefor ISOIMAGE inputs { KERNEL, GRUBCFG, LIBSUPCS, MSCORLIB, PROCESSES, GRUBPREFIX_CFG } depends { ISODIR, BOOTDIR, GRUBDIR, CDBOOT }
	{
		cp(KERNEL, ISODIR);
		cp(GRUBCFG, GRUBDIR);
		cp(LIBSUPCS, ISODIR);
		cp(MSCORLIB, ISODIR);

		foreach(proc in PROCESSES)
		{
			cp(proc, ISODIR);
		}

		shellcmd("$GRUB_MKIMAGE -o $COREIMG -c $GRUBPREFIX_CFG -O i386-pc biosdisk multiboot configfile normal iso9660");
	
		fcdboot = fopen(CDBOOT);
		fcoreimg = fopen(COREIMG);

		bcdboot = [];
		fcdboot.Read(bcdboot, 0, fcdboot.Length);

		bcoreimg = [];
		fcoreimg.Read(bcoreimg, 0, fcoreimg.Length);

		if(exists(ELTORITO))
		{
			rm(ELTORITO);
		}

		feltorito = fopen(ELTORITO);
		feltorito.Write(bcdboot, 0, fcdboot.Length);
		feltorito.Write(bcoreimg, 0, fcoreimg.Length);

		shellcmd("$XORRISO -as mkisofs -R -f -b boot/grub/eltorito.img -no-emul-boot -boot-load-size 4 -boot-info-table -o $ISOIMAGE $ISODIR");
	}
}
else if(defined(USE_UEFI))
{
	IMGDIR = OUTDIR + "/img";
	autodir(IMGDIR + "/EFI/BOOT");
	autodir(IMGDIR + "/boot");

	BOOT_MNU = OUTDIR + "/boot.mnu";

	rulefor ISOIMAGE inputs { KERNEL, LIBSUPCS, MSCORLIB, PROCESSES, EFILOADER, BOOT_MNU } depends { IMGDIR, IMGDIR + "/EFI/BOOT", IMGDIR + "/boot", ISODIR }
	{
		cp(KERNEL, IMGDIR);
		cp(LIBSUPCS, IMGDIR);
		cp(MSCORLIB, IMGDIR);
		cp(BOOT_MNU, IMGDIR + "/boot");

		foreach(proc in PROCESSES)
		{
			cp(proc, IMGDIR);
		}

		// Compress kernel
		shellcmd("gzip -f $IMGDIR/tysos.bin");

		cp(EFILOADER, IMGDIR + "/EFI/BOOT/BOOTX64.EFI");

		shellcmd("mkfat -o $ISODIR/efi.img $IMGDIR");
		shellcmd("$XORRISO -as mkisofs -R -f --efi-boot efi.img -no-emul-boot -o $ISOIMAGE $ISODIR");
	}
}

build(ISOIMAGE);
